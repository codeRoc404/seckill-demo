# .秒杀系统

- 后端：SpringBoot + MyBatisPlus + MySQL + Redis + RabbitMQ + Nginx + Shiro +JWT
- 前端：Vue + ElementUI + Axios  
- Vue-admin-template模板：https://panjiachen.gitee.io/vue-element-admin-site/zh/
- SpringBoot 2.7.9  Jdk1.8

## 秒杀方案

- 基于 Shiro + JWT 实现登录、身份认证、授权、资源访问拦截

- 基于 Redis + Lua 实现数据缓存、分布式锁

  ![6f4c9dce803030bb33e528a67465b18](E:\Documents\后端学习资料\秒杀项目\imgs\6f4c9dce803030bb33e528a67465b18.png)

## MybatisPlus代码生成器

官网地址：https://baomidou.com/

```java
package com.zzp.seckilldemo.common.utils;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.generator.FastAutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.OutputFile;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
import com.baomidou.mybatisplus.generator.fill.Column;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;


public class CodeGenerator {
    private static final String url = "jdbc:mysql://localhost:3306/seckill?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai";
    private static final String username = "root";
    private static final String password = "zzp";

    public static void main(String[] args) {
//        new CodeGenerator().autoGenerator();
        new CodeGenerator().interactiveGenerator();
    }

    //自动生成方式
    void autoGenerator() {
        FastAutoGenerator.create(url, username, password)
                .globalConfig(builder -> {
                    builder.author("zzp") // 设置作者
                            // .enableSwagger() // 开启 swagger 模式
                            .fileOverride() // 覆盖已生成文件
                            .outputDir("E:\\WorkSpace\\seckill-demo\\src\\main\\java"); // 指定输出目录
                })
                .packageConfig(builder -> {
                    builder.parent("com.zzp.seckilldemo") // 设置父包名
                            .moduleName("") // 设置父包模块名
                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, "E:\\WorkSpace\\seckill-demo\\src\\main\\resources\\mapper")); // 设置mapperXml生成路径
                })
                .strategyConfig(builder -> {
                    builder.addInclude("user") // 设置需要生成的表名
                            .addTablePrefix("t_", "c_"); // 设置过滤表前缀

                    builder.serviceBuilder()
                            .formatServiceFileName("%sService") //设置service的命名策略,没有这个配置的话，生成的service和serviceImpl类前面会有一个I，比如IUserService和IUserServiceImpl
                            .formatServiceImplFileName("%sServiceImpl"); //设置serviceImpl的命名策略
                    builder.controllerBuilder()
                            .enableRestStyle(); // 开启生成@RestController 控制器，不配置这个默认是Controller注解，RestController是返回Json字符串的，多用于前后端分离项目。
                    builder.mapperBuilder()
                            .enableMapperAnnotation();//开启 @Mapper 注解，也就是在dao接口上添加一个@Mapper注解，这个注解的作用是开启注解模式，就可以在接口的抽象方法上面直接使用@Select和@Insert和@Update和@Delete注解。

                })
                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                .execute();
    }

    /**
     * 数据源配置
     */
    private static final DataSourceConfig.Builder DATA_SOURCE_CONFIG = new DataSourceConfig.Builder(url, username, password);
    private static final String absolutePath = "E:\\WorkSpace\\seckill-demo\\src\\main\\java\\";

    //交互生成方式
    void interactiveGenerator() {
        FastAutoGenerator.create(DATA_SOURCE_CONFIG)
                // 全局配置
                .globalConfig((scanner, builder) -> builder.author(scanner.apply("请输入作者名称？")).fileOverride().outputDir(absolutePath))
                // 包配置
                .packageConfig((scanner, builder) -> builder.parent(scanner.apply("请输入包名？"))
                        .pathInfo(Collections.singletonMap(OutputFile.mapperXml, "E:\\WorkSpace\\seckill-demo\\src\\main\\resources\\mapper"))) // 设置mapperXml生成路径)
                // 策略配置
                .strategyConfig((scanner, builder) -> builder.addInclude(getTables(scanner.apply("请输入表名，多个英文逗号分隔？所有输入 all")))
                        .addTablePrefix("t_", "c_") // 设置过滤表前缀
                        .controllerBuilder().enableHyphenStyle()//.enableRestStyle() @RestController
                        .serviceBuilder()
                        .formatServiceFileName("%sService") //设置service的命名策略,没有这个配置的话，生成的service和serviceImpl类前面会有一个I，比如IUserService和IUserServiceImpl
                        .formatServiceImplFileName("%sServiceImpl")//设置serviceImpl的命名策略
                        .mapperBuilder()
                        .enableMapperAnnotation()//开启 @Mapper 注解
                        .entityBuilder().enableLombok().addTableFills(
                                new Column("create_time", FieldFill.INSERT)
                        ).build())
                /*
                    模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker
                   .templateEngine(new BeetlTemplateEngine())
                   .templateEngine(new FreemarkerTemplateEngine())
                 */
                .templateEngine(new FreemarkerTemplateEngine())
                .execute();
    }

    // 处理 all 情况
    protected static List<String> getTables(String tables) {
        return "all".equals(tables) ? Collections.emptyList() : Arrays.asList(tables.split(","));
    }
}
```

## SQL

```sql
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for permission
-- ----------------------------
DROP TABLE IF EXISTS `permission`;
CREATE TABLE `permission`  (
  `id` int NOT NULL DEFAULT 0 COMMENT '自定id,主要供前端展示权限列表分类排序使用.',
  `menu_code` varchar(255) NULL DEFAULT '' COMMENT '归属菜单,前端判断并展示菜单使用,',
  `menu_name` varchar(255) NULL DEFAULT '' COMMENT '菜单的中文释义',
  `permission_code` varchar(255) NULL DEFAULT '' COMMENT '权限的代码/通配符,对应代码中@RequiresPermissions 的value',
  `permission_name` varchar(255) NULL DEFAULT '' COMMENT '本权限的中文释义',
  `required_permission` tinyint(1) NULL DEFAULT 2 COMMENT '是否本菜单必选权限, 1.必选 2非必选 通常是\"列表\"权限是必选',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '后台权限表';

-- ----------------------------
-- Records of permission
-- ----------------------------
INSERT INTO `permission` VALUES (101, 'user', '用户', 'user:list', '列表', 2);
INSERT INTO `permission` VALUES (102, 'user', '用户', 'user:add', '新增', 2);
INSERT INTO `permission` VALUES (201, 'role', '角色管理', 'role:list', '列表', 2);
INSERT INTO `permission` VALUES (202, 'role', '角色管理', 'role:add', '新增', 2);
INSERT INTO `permission` VALUES (301, 'commodity', '商品管理', 'com:purchase', '购买', 2);
INSERT INTO `permission` VALUES (302, 'commodity', '商品管理', 'com:list', '列表', 2);

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_name` varchar(20) NULL DEFAULT NULL COMMENT '角色名',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `delete_stauts` varchar(1) NULL DEFAULT '1' COMMENT '是否有效 1有效 2无效',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '后台角色表';

-- ----------------------------
-- Records of role
-- ----------------------------
INSERT INTO `role` VALUES (1, 'admin', '2023-03-27 19:43:48', '2023-03-28 18:57:54', '1');
INSERT INTO `role` VALUES (2, 'nomuser', '2023-03-27 19:43:59', '2023-03-28 18:58:14', '1');

-- ----------------------------
-- Table structure for role_permission
-- ----------------------------
DROP TABLE IF EXISTS `role_permission`;
CREATE TABLE `role_permission`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_id` int DEFAULT NULL COMMENT '角色id',
  `permission_id` int DEFAULT NULL COMMENT '权限id',
  `create_time` timestamp DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `delete_status` varchar(1) NULL DEFAULT '1' COMMENT '是否有效 1有效     2无效',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '角色-权限关联表';

-- ----------------------------
-- Records of role_permission
-- ----------------------------
INSERT INTO `role_permission` VALUES (1, 1, 101, '2023-03-27 19:49:07', '2023-03-27 19:49:07', '1');
INSERT INTO `role_permission` VALUES (2, 1, 102, '2023-03-27 19:49:13', '2023-03-27 19:49:13', '1');
INSERT INTO `role_permission` VALUES (3, 1, 201, '2023-03-27 19:49:19', '2023-03-27 19:49:19', '1');
INSERT INTO `role_permission` VALUES (4, 1, 202, '2023-03-27 19:49:24', '2023-03-27 19:49:24', '1');
INSERT INTO `role_permission` VALUES (5, 2, 101, '2023-03-27 19:49:35', '2023-03-27 19:49:35', '1');
INSERT INTO `role_permission` VALUES (6, 2, 102, '2023-03-27 19:49:40', '2023-03-27 19:49:40', '1');
INSERT INTO `role_permission` VALUES (7, 1, 301, '2023-03-28 19:09:18', '2023-03-28 19:09:18', '1');
INSERT INTO `role_permission` VALUES (8, 1, 302, '2023-03-28 19:09:26', '2023-03-28 19:09:26', '1');
INSERT INTO `role_permission` VALUES (9, 2, 301, '2023-03-28 19:09:38', '2023-03-28 19:09:38', '1');

-- ----------------------------
-- Table structure for t_goods
-- ----------------------------
DROP TABLE IF EXISTS `t_goods`;
CREATE TABLE `t_goods`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '商品Id',
  `goods_name` varchar(16) NULL DEFAULT NULL COMMENT '商品名称',
  `goods_title` varchar(64) NULL DEFAULT NULL COMMENT '商品标题',
  `goods_img` varchar(128) NULL DEFAULT NULL COMMENT '商品图片',
  `goods_detail` longtext NULL COMMENT '商品详情',
  `goods_price` decimal(10, 2) DEFAULT 0.00 COMMENT '商品价格',
  `goods_stock` int DEFAULT 0 COMMENT '商品库存，-1表示没有限制',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;

-- ----------------------------
-- Records of t_goods
-- ----------------------------
INSERT INTO `t_goods` VALUES (1, 'iphone 14 pro', 'Apple手机', 'http://localhost:8001/img/iphone14.jpg', '64g', 5000.00, 100);
INSERT INTO `t_goods` VALUES (2, '小米13', 'XiaoMi手机', 'http://localhost:8001/img/xiaomi13.jpg', '64g', 4599.00, 100);

-- ----------------------------
-- Table structure for t_order
-- ----------------------------
DROP TABLE IF EXISTS `t_order`;
CREATE TABLE `t_order`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '订单Id',
  `user_id` bigint DEFAULT NULL COMMENT '用户Id',
  `goods_id` bigint DEFAULT NULL COMMENT '商品Id',
  `delivery_addr_id` bigint DEFAULT NULL COMMENT '收货地址Id',
  `goods_name` varchar(16) DEFAULT NULL COMMENT '商品名称',
  `goods_count` int DEFAULT 0 COMMENT '商品数量',
  `goods_price` decimal(10, 2) DEFAULT 0.00 COMMENT '商品单价',
  `order_channel` tinyint DEFAULT 0 COMMENT '1:pc端，2：手机端',
  `status` tinyint DEFAULT 0 COMMENT '订单状态，0：新建未支付，1：已支付，2：已发货，3：已收货，4：已退款，5：已完成',
  `create_date` datetime DEFAULT NULL COMMENT '订单创建时间',
  `pay_date` datetime DEFAULT NULL COMMENT '订单支付时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 116143 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;

-- ----------------------------
-- Records of t_order
-- ----------------------------

-- ----------------------------
-- Table structure for t_seckill_goods
-- ----------------------------
DROP TABLE IF EXISTS `t_seckill_goods`;
CREATE TABLE `t_seckill_goods`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '秒杀商品Id',
  `goods_id` bigint DEFAULT NULL COMMENT '商品Id',
  `seckill_price` decimal(10, 2) DEFAULT 0.00 COMMENT '秒杀价',
  `stock_count` int DEFAULT NULL COMMENT '库存数量',
  `start_date` datetime DEFAULT NULL COMMENT '秒杀开始时间',
  `end_date` datetime DEFAULT NULL COMMENT '秒杀结束时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;

-- ----------------------------
-- Records of t_seckill_goods
-- ----------------------------
INSERT INTO `t_seckill_goods` VALUES (1, 1, 4500.00, 9995, '2023-04-01 17:02:00', '2023-04-06 17:05:00');
INSERT INTO `t_seckill_goods` VALUES (2, 2, 4099.00, 4997, '2023-04-05 20:53:15', '2023-04-22 20:53:18');

-- ----------------------------
-- Table structure for t_seckill_order
-- ----------------------------
DROP TABLE IF EXISTS `t_seckill_order`;
CREATE TABLE `t_seckill_order`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '秒杀订单Id',
  `user_id` bigint DEFAULT NULL COMMENT '用户Id',
  `order_id` bigint DEFAULT NULL COMMENT '订单Id',
  `goods_id` bigint DEFAULT NULL COMMENT '商品Id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 187496 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;

-- ----------------------------
-- Records of t_seckill_order
-- ----------------------------

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint NOT NULL COMMENT '用户id，手机号码',
  `nickname` varchar(255) NOT NULL,
  `password` varchar(32) NULL DEFAULT NULL COMMENT 'MD5(MD5(password明文+固定salt)+salt)',
  `salt` varchar(10) NULL DEFAULT NULL,
  `head` varchar(128) NULL DEFAULT NULL COMMENT '头像',
  `register_date` datetime DEFAULT NULL COMMENT '注册时间',
  `last_login_date` datetime DEFAULT NULL COMMENT '最后一次登录时间',
  `login_count` int DEFAULT 0 COMMENT '登录次数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;

-- ----------------------------
-- Records of t_user
-- ----------------------------

INSERT INTO `t_user` VALUES (15139769049, '莫嘉伦', '8e8bd4a115b9896cc27e8847ab611724', 'zxcvbn', NULL, NULL, NULL, 0);

-- ----------------------------
-- Table structure for user_role
-- ----------------------------
DROP TABLE IF EXISTS `user_role`;
CREATE TABLE `user_role`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL COMMENT '用户id',
  `role_id` int DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户-角色关联表';

-- ----------------------------
-- Records of user_role
-- ----------------------------
INSERT INTO `user_role` VALUES (1, 15139769049, 1);
INSERT INTO `user_role` VALUES (2, 18012099705, 2);
INSERT INTO `user_role` VALUES (3, 15139769049, 2);

SET FOREIGN_KEY_CHECKS = 1;
```

## 前后端跨域处理

```java
package com.zzp.seckilldemo.config;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;


/**
 * @Author zzp
 * @Date 2023/3/22 15:47
 * @Description: 跨域问题
 * @Version 1.0
 */
//在JwtFilter中配置了跨域设置，此处就无需配置
//@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        //1.添加CORS配置信息
        CorsConfiguration config = new CorsConfiguration();
        //开放哪些ip、端口、域名的访问权限，*表示开放所有域
        config.addAllowedOriginPattern("*");
        //是否发送Cookie信息
        config.setAllowCredentials(true);
        //开放哪些Http方法，允许跨域访问
        config.addAllowedMethod("*");
        ////允许HTTP请求中的携带哪些Header信息
        config.addAllowedHeader("*");
        //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
        //config.addExposedHeader("*");
        config.addExposedHeader("Content-Type");
        config.addExposedHeader( "X-Requested-With");
        config.addExposedHeader("accept");
        config.addExposedHeader("Origin");
        config.addExposedHeader( "Access-Control-Request-Method");
        config.addExposedHeader("Access-Control-Request-Headers");

        //2.添加映射路径
        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();
        configSource.registerCorsConfiguration("/**", config);

        //3.返回新的CorsFilter.
        return new CorsFilter(configSource);
    }

}
```

## 统一响应处理

参考jeecg-boot源码：https://gitee.com/jeecg

```java
package com.zzp.seckilldemo.common;

import lombok.Data;

import java.io.Serializable;


/**
 * @Author zzp
 * @Date 2023/3/22 12:23
 * @Description: 统一响应处理
 * @Version 1.0
 */
@Data
public class Result<T> implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 成功标志
     */
    private boolean success = true;

    /**
     * 返回代码
     */
    private Integer code = 0;

    /**
     * 返回处理消息
     */
    private String message = "";

    /**
     * 返回数据对象data
     */
    private T data;

    /**
     * 时间戳
     */
    private long timestamp = System.currentTimeMillis();


    public static <T> Result<T> ok() {
        Result<T> r = new Result<T>();
        r.setSuccess(true);
        r.setCode(CommonConstant.SC_OK_200);
        return r;
    }

    public static <T> Result<T> ok(String msg) {
        Result<T> r = new Result<T>();
        r.setSuccess(true);
        r.setCode(CommonConstant.SC_OK_200);
        r.setMessage(msg);
        return r;
    }

    public static <T> Result<T> ok(T data) {
        Result<T> r = new Result<T>();
        r.setSuccess(true);
        r.setCode(CommonConstant.SC_OK_200);
        r.setData(data);
        return r;
    }

    public static <T> Result<T> ok(String msg, T data) {
        Result<T> r = new Result<T>();
        r.setSuccess(true);
        r.setCode(CommonConstant.SC_OK_200);
        r.setMessage(msg);
        r.setData(data);
        return r;
    }

    public static <T> Result<T> error500(String msg) {
        return error(CommonConstant.SC_INTERNAL_SERVER_ERROR_500, msg);
    }

    public static <T> Result<T> error500(String msg, T data) {
        Result<T> r = new Result<T>();
        r.setSuccess(false);
        r.setCode(CommonConstant.SC_INTERNAL_SERVER_ERROR_500);
        r.setMessage(msg);
        r.setData(data);
        return r;
    }

    public static <T> Result<T> error(int code, String msg) {
        Result<T> r = new Result<T>();
        r.setSuccess(false);
        r.setCode(code);
        r.setMessage(msg);
        return r;
    }


    /**
     * 无权限访问返回结果
     */
    public static <T> Result<T> noauth(String msg) {
        return error(CommonConstant.SC_NO_AUTHZ, msg);
    }

}
```

```java
package com.zzp.seckilldemo.common;

/**
 * @Author zzp
 * @Date 2023/3/22 14:16
 * @Description: 通用常量
 * @Version 1.0
 */
public interface CommonConstant {

    /**
     * {@code 200 OK} (HTTP/1.0 - RFC 1945)
     */
    Integer SC_OK_200 = 200;

    /**
     * {@code 500 Server Error} (HTTP/1.0 - RFC 1945)
     */
    Integer SC_INTERNAL_SERVER_ERROR_500 = 500;

    /**
     * 访问权限认证未通过 510
     */
    Integer SC_NO_AUTHZ=510;
}
```

## 统一异常处理

```java
package com.zzp.seckilldemo.common.exception;

/**
 * @Author zzp
 * @Date 2023/3/23 13:02
 * @Description: 自定义异常
 * @Version 1.0
 */
public class TokenApiException extends RuntimeException{
    private static final long serialVersionUID = 1L;

    public TokenApiException(String message) {
        super(message);
    }

    public TokenApiException(Throwable cause) {
        super(cause);
    }

    public TokenApiException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

```java
package com.zzp.seckilldemo.common.exception;

import com.zzp.seckilldemo.common.CommonConstant;
import com.zzp.seckilldemo.common.Result;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.validation.BindException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * @Author zzp
 * @Date 2023/3/23 12:40
 * @Description: 统一异常处理
 * @Version 1.0
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 处理自定义异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler(value = TokenApiException.class)
    public Result<?> handleTokenException(TokenApiException e) {
        log.error(e.getMessage(), e);
        return Result.error(CommonConstant.INVALID_TOKEN, e.getMessage());
    }

    @ExceptionHandler(value = BindException.class)
    public Result<?> handleValidException(BindException e) {
        return Result.error500("请注意输入格式");
    }

    @ExceptionHandler(value = ExpiredJwtException.class)
    public Result<?> handleException(ExpiredJwtException e) {
        return Result.error(CommonConstant.UNAUTHORIZED, "认证失效，请重新登录");
    }
}
```

## Swagger2

swagger教程：https://www.bmrs.top/springboot/springboot7.html#springboot%E9%9B%86%E6%88%90swagger

SpringBoot2.7.9集成Swagger2

```XML
<!--Swagger-->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-boot-starter</artifactId>
    <version>3.0.0</version>
</dependency>
```

```JAVA
package com.zzp.seckilldemo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;

/**
 * @Author zzp
 * @Date 2023/3/25 12:17
 * @Description: Swagger配置类
 * @Version 1.0
 */
@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket docket(Environment environment) {
        // 设置项目处于哪些环境时, 需要开启 swagger
        // Profiles.of("dev", "test") 处于 dev test 环境 开启 swagger
        Profiles of = Profiles.of("dev", "test");
        // 判断当前项目所处环境, 如果为 dev test 环境, 返回 true
        // 通过 enable() 接收此参数判断并决定是否显示
        boolean b = environment.acceptsProfiles(of);

        return new Docket(DocumentationType.SWAGGER_2).
                apiInfo(apiInfo()).
                enable(b).
                select().
                // 通过 .select() 方法去配置扫描接口, RequestHandlerSelectors 配置如何扫描接口
                apis(RequestHandlerSelectors.basePackage("com.zzp.seckilldemo.controller")).
                build();
    }

    // 配置文档信息
    public ApiInfo apiInfo() {
        // contact 联系人信息
        Contact contact = new Contact("codeRoc", "", "");
        return new ApiInfoBuilder()
                .title("秒杀系统")
                .description("秒杀系统接口管理")
                .version("v1.0")
                .contact(contact)
                .build();
    }
}
```

- `springboot2.6.0`中将`SpringMVC` 默认路径匹配策略从`AntPathMatcher` 更改为`PathPatternParser`，导致出错。可以在启动类上加上`@EnableWebMvc`注解或者在配置中切换为原先的`AntPathMatcher`：`spring.mvc.pathmatch.matching-strategy=ant_path_matcher`

  ```java
  @SpringBootApplication
  @MapperScan("com.zzp.seckilldemo.mapper")
  @EnableWebMvc
  public class SeckillDemoApplication {

      public static void main(String[] args) {
          SpringApplication.run(SeckillDemoApplication.class, args);
      }
  }
  ```

## JSR303

```xml
<!--数据校验 SpringBoot 2.3 版本以上-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

### 自定义注解

```java
package com.zzp.seckilldemo.common.validator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

/**
 * @Author zzp
 * @Date 2023/3/24 16:23
 * @Description: 手机号格式校验注解
 * @Version 1.0
 */
@Documented
@Constraint(
        validatedBy = {IsPhoneValidator.class}
)
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
public @interface IsPhone {

    String message() default "手机号格式错误";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

```java
package com.zzp.seckilldemo.common.validator;

import com.zzp.seckilldemo.common.utils.ValidatorUtil;
import org.apache.commons.lang3.StringUtils;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

/**
 * @Author zzp
 * @Date 2023/3/24 16:26
 * @Description: 手机号格式校验器
 * @Version 1.0
 */
public class IsPhoneValidator implements ConstraintValidator<IsPhone, String> {

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if (StringUtils.isEmpty(s)) {
            return false;
        } else
            return ValidatorUtil.isPhone(s);
    }
}
```

```java
/**
 * @Author zzp
 * @Date 2023/3/22 19:18
 * @Description: 手机号格式校验规则
 * @Version 1.0
 */
public class ValidatorUtil {

    private static final Pattern phone_pattern = Pattern.compile("[1]([3-9])[0-9]{9}$");

    public static boolean isPhone(String phone){
        if (StringUtils.isEmpty(phone)){
            return false;
        }
        Matcher matcher = phone_pattern.matcher(phone);
        return matcher.matches();
    }
}
```

```java
@Data
public class LoginVo {

    @NotBlank
    @IsPhone //自定义注解
    private String phone;

    @NotBlank
    private String password;
}
```

```java
@PostMapping("/login")
//@Valid注解拦截校验
public Result login(@Valid @RequestBody LoginVo loginVo){
	return userService.doLogin(loginVo);
}
```

## 登录功能

### md5+salt(盐)两次加密

客户端MD5：HTTP在网络上是使用明文传输，用户输入的明文密码直接在网络上传输太危险。所以，在客户端先进行一次MD5(明文+固定盐)。

服务端：服务端接受到后，也不是直接写入到数据库，而是生成一个随机盐，再进行一次MD5，防止数据库被入侵，被人通过彩虹表反查出密码。

```xml
<!--md5依赖-->
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency>
```



## jwt与token+redis

https://www.zhihu.com/question/274566992/answer/2270860305

https://www.bmrs.top/edu/backend/key.html#springboot-%E6%95%B4%E5%90%88-jwt

```xml
<!-- JWT 跨域身份验证-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

### JwtUtil

```java
package com.zzp.seckilldemo.common.utils;

/**
 * @Author zzp
 * @Date 2023/3/24 23:23
 * @Description: JWT工具类
 * @Version 1.0
 */

import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.zzp.seckilldemo.common.CommonConstant;
import com.zzp.seckilldemo.common.exception.TokenApiException;
import io.jsonwebtoken.*;


import javax.servlet.http.HttpServletRequest;
import java.util.Date;

public class JwtUtil {

    //密钥
    private static final String secret = CommonConstant.TOKEN_SECRET;
    //有效时长
    private static final long expire = CommonConstant.TOKEN_EXPIRE;

    /**
     * 创建token
     *
     * @param id
     * @param nickname
     * @return
     */
    public static String creatToken(Long id, String nickname) {
        Date nowDate = new Date();
        Date expiredDate = new Date(nowDate.getTime() + expire);
        return Jwts.builder()
                .setHeaderParam("typ", "JWT")
                .setHeaderParam("alg", "HS256")
                .setIssuedAt(nowDate)
                .setExpiration(expiredDate)
                .claim("id", id) //自定义声明
                .claim("username", nickname)
                .signWith(SignatureAlgorithm.HS256, secret)
                .compact();
    }

    /**
     * 验证 token 是否存在且有效
     *
     * @param request
     * @return
     */
    public static boolean checkToken(HttpServletRequest request) {
        try {
            String jwtToken = request.getHeader(CommonConstant.X_ACCESS_TOKEN);
            if (StringUtils.isEmpty(jwtToken))
                return false;
            Jwts.parser().setSigningKey(secret).parseClaimsJws(jwtToken);
        } catch (ExpiredJwtException e) {
            throw new TokenApiException("验证已过期，请重新登录");
        } catch (Exception e) {
            throw new TokenApiException("token验证失败");
        }
        return true;
    }

    public static boolean verifyToken(String token) {
        try {
            if (StringUtils.isEmpty(token))
                return false;
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
        } catch (ExpiredJwtException e) {
            throw new TokenApiException("验证已过期，请重新登录");
        } catch (Exception e) {
            throw new TokenApiException("token验证失败");
        }
        return true;
    }

    /**
     * 根据token获取用户id
     *
     * @param token
     * @return
     */
    public static Long getUserIdByJwtToken(String token) {
        if (StringUtils.isEmpty(token))
            throw new TokenApiException("请先登录");
        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
        Claims claims = claimsJws.getBody();
        return (Long)claims.get("id");
    }
}
```

### 配置拦截器

整合Shiro之前，自定义拦截器进行登录拦截

整合Shiro之后，可不使用此种方法

```java
package com.zzp.seckilldemo.config;

import com.zzp.seckilldemo.common.exception.TokenApiException;
import com.zzp.seckilldemo.config.shiro.JwtToken;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @Author zzp
 * @Date 2023/3/25 13:24
 * @Description: token验证拦截器
 * @Version 1.0
 */
public class TokenInterceptor implements HandlerInterceptor {
    /**
     * 拦截器：验证用户是否登录
     *
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {

        //验证token是否有效
        boolean b = JwtToken.checkToken(request);
        if (!b) {
            throw new TokenApiException("请先登录");
        }
        return true;
    }
}

```

```
package com.zzp.seckilldemo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Author zzp
 * @Date 2023/3/25 14:06
 * @Description: TODO
 * @Version 1.0
 */
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 注册自定义拦截器
     *
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new TokenInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/user/login");//开放路径
    }
}
```

## Redis

在启动类上添加注解，开启缓存注解

![c97331045e389f764daf336df112338](.\imgs\c97331045e389f764daf336df112338.png)

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

### RedisConfig配置类

```java
package com.zzp.seckilldemo.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.*;

import java.time.Duration;


/**
 * @Author zzp
 * @Date 2023/3/26 13:27
 * @Description: redis配置
 * @Version 1.0
 */
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        //注入连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        /**
         * JSON序列化
         */
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = this.jacksonSerializer();

        RedisSerializer<String> stringSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringSerializer);
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(stringSerializer);
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();

        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = this.jacksonSerializer();

        // 配置序列化（解决乱码的问题）,过期时间60秒
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(60)) //过期时间
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }

    private Jackson2JsonRedisSerializer jacksonSerializer() {
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        //设置格式化输出
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        return jackson2JsonRedisSerializer;
    }

}
```

## Shiro

https://www.bmrs.top/springboot/springboot6.html#shiro-%E7%AE%80%E4%BB%8B

```xml
<!--SpringBoot 整合 Shiro-->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring</artifactId>
    <version>1.4.1</version>
</dependency>
```

### RBAC(基于角色控制访问)

https://github.com/Heeexy/SpringBoot-Shiro-Vue

基于 [RBAC新解](http://globeeip.iteye.com/blog/1236167) .

通常我们的权限设计都是 用户--角色--权限 ,其中**角色**是我们写代码的人没法控制的,它可以有多条权限,每个用户又可以设计为拥有多个角色.因此如果从角色着手进行权限验证,系统都必须根据用户的配置动起来,非常复杂.

所以我们后台设计的关键点就在于: **后台接口只验证权限,不看角色.**

角色的作用其实只是用来管理分配权限的,真正的验证只验证**权限** ,而不去管你是否是那种角色。

```sql
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(20) DEFAULT NULL COMMENT '角色名',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效  1有效  2无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB COMMENT='后台角色表';

DROP TABLE IF EXISTS `sys_permission`;
CREATE TABLE `sys_permission` (
  `id` int(11) NOT NULL DEFAULT '0' COMMENT '自定id,主要供前端展示权限列表分类排序使用.',
  `menu_code` varchar(255) DEFAULT '' COMMENT '归属菜单,前端判断并展示菜单使用,',
  `menu_name` varchar(255) DEFAULT '' COMMENT '菜单的中文释义',
  `permission_code` varchar(255) DEFAULT '' COMMENT '权限的代码/通配符,对应代码中@RequiresPermissions 的value',
  `permission_name` varchar(255) DEFAULT '' COMMENT '本权限的中文释义',
  `required_permission` tinyint(1) DEFAULT '2' COMMENT '是否本菜单必选权限, 1.必选 2非必选 通常是"列表"权限是必选',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB COMMENT='后台权限表';

DROP TABLE IF EXISTS `sys_role_permission`;
CREATE TABLE `sys_role_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `role_id` int(11) DEFAULT NULL COMMENT '角色id',
  `permission_id` int(11) DEFAULT NULL COMMENT '权限id',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效     2无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB COMMENT='角色-权限关联表';

DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL COMMENT '用户id',
  `role_id` int(11) DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB COMMENT='用户-角色关联表';
```

### Shiro+Jwt

https://blog.csdn.net/Huangjiazhen711/article/details/127508946

- Shiro+Jwt结合使用时，可以不再配置jwt拦截器，转为配置JwtFilter过滤器，并加入至ShiroConfig中
- 在 shiro 中，shiroFilter 用来拦截所有请求。
- 但是 shiro 要和 jwt 整合，所以要使用自定义的过滤器 JwtFilter。
- JwtFilter 的主要作用就是拦截请求，判断请求头中是否携带 token。如果携带，就交给 Realm 处理。

### JwtFilter

```java
package com.zzp.seckilldemo.config.shiro.filters;

import com.zzp.seckilldemo.common.CommonConstant;
import com.zzp.seckilldemo.common.exception.TokenApiException;
import com.zzp.seckilldemo.config.shiro.JwtToken;
import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;

/**
 * @Author zzp
 * @Date 2023/3/25 13:24
 * @Description: jwt过滤器
 * @Version 1.0
 */
@Slf4j
public class JwtFilter extends BasicHttpAuthenticationFilter {


    /**
     * 执行登录认证
     *
     * @param request
     * @param response
     * @param mappedValue
     * @return
     */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
        try {
            executeLogin(request, response);
            return true;
        } catch (Exception e) {
            throw new TokenApiException("请重新登录");
        }
    }

    @Override
    protected boolean executeLogin(ServletRequest request, ServletResponse response) {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        String token = httpServletRequest.getHeader(CommonConstant.X_ACCESS_TOKEN);
        JwtToken jwtToken = new JwtToken(token);
        /**
         *  提交给realm进行登入，如果错误他会抛出异常并被捕获
         *  这里getSubject方法实际上就是获得一个subject
         *  与原生shiro不同的地方在于没有对username和password进行封装
         *  直接使用jwt进行认真，login方法实际上就是交给Realm进行认证
         */
        getSubject(request, response).login(jwtToken);
        // 如果没有抛出异常则代表登入成功，返回true
        return true;
    }

}
```

### ShiroConfig

```java
package com.zzp.seckilldemo.config.shiro;

import com.zzp.seckilldemo.config.shiro.filters.JwtFilter;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;
import org.apache.shiro.mgt.DefaultSubjectDAO;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.crazycake.shiro.IRedisManager;
import org.crazycake.shiro.RedisCacheManager;
import org.crazycake.shiro.RedisClusterManager;
import org.crazycake.shiro.RedisManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.JedisCluster;

import javax.annotation.Resource;
import javax.servlet.Filter;
import java.util.*;

/**
 * @Author zzp
 * @Date 2023/3/27 19:50
 * @Description: shiro配置类
 * @Version 1.0
 */
@Configuration
@Slf4j
public class ShiroConfig {


    @Resource
    private LettuceConnectionFactory lettuceConnectionFactory;

    /**
     * Filter Chain定义说明
     * <p>
     * 1、一个URL可以配置多个Filter，使用逗号分隔
     * 2、当设置多个过滤器时，全部验证通过，才视为通过
     * 3、部分过滤器可指定参数，如perms，roles
     */
    // ShiroFilterFactoryBean
    @Bean("shiroFilterFactoryBean")
    public ShiroFilterFactoryBean shiroFilter(@Qualifier("securityManager") DefaultWebSecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        // 设置安全管理器
        shiroFilterFactoryBean.setSecurityManager(securityManager);

        // 拦截器
        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();
        // 配置不会被拦截的链接 顺序判断
        filterChainDefinitionMap.put("/user/login", "anon"); //登录接口排除
        filterChainDefinitionMap.put("/user/logout", "anon"); //登出接口排除
        filterChainDefinitionMap.put("/goods/**", "anon");
        filterChainDefinitionMap.put("/order/**", "anon");

        filterChainDefinitionMap.put("/", "anon");
        filterChainDefinitionMap.put("/doc.html", "anon");
        filterChainDefinitionMap.put("/**/*.js", "anon");
        filterChainDefinitionMap.put("/**/*.css", "anon");
        filterChainDefinitionMap.put("/**/*.html", "anon");
        filterChainDefinitionMap.put("/**/*.svg", "anon");
        filterChainDefinitionMap.put("/**/*.pdf", "anon");
        filterChainDefinitionMap.put("/**/*.jpg", "anon");
        filterChainDefinitionMap.put("/**/*.png", "anon");
        filterChainDefinitionMap.put("/**/*.gif", "anon");
        filterChainDefinitionMap.put("/**/*.ico", "anon");
        filterChainDefinitionMap.put("/**/*.ttf", "anon");
        filterChainDefinitionMap.put("/**/*.woff", "anon");
        filterChainDefinitionMap.put("/**/*.woff2", "anon");

        filterChainDefinitionMap.put("/druid/**", "anon");
        filterChainDefinitionMap.put("/swagger-ui.html", "anon");
        filterChainDefinitionMap.put("/swagger**/**", "anon");
        filterChainDefinitionMap.put("/webjars/**", "anon");
        filterChainDefinitionMap.put("/v2/**", "anon");

//        filterChainDefinitionMap.put("/user/info", "perms[user:list]"); //配置权限访问

        // 添加自己的过滤器并且取名为jwt
        Map<String, Filter> filterMap = new HashMap<>(1);
        filterMap.put("jwt", new JwtFilter());
        shiroFilterFactoryBean.setFilters(filterMap);
        // <!-- 过滤链定义，从上向下顺序执行，一般将/**放在最为下边
        filterChainDefinitionMap.put("/**", "jwt");


        shiroFilterFactoryBean.setUnauthorizedUrl("/user/unauth");
        // 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面
        shiroFilterFactoryBean.setLoginUrl("/user/unauth");

        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    // DefaultWebSecurityManager
    @Bean(name = "securityManager")
    public DefaultWebSecurityManager securityManager(ShiroRealm shiroRealm) {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        // 关联 UserRealm
        securityManager.setRealm(shiroRealm);
        /*
         * 关闭shiro自带的session（无状态的方式使用shiro），详情见文档
         * http://shiro.apache.org/session-management.html#SessionManagement-
         * StatelessApplications%28Sessionless%29
         */
        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();
        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator();
        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);
        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);
        securityManager.setSubjectDAO(subjectDAO);
        //自定义缓存实现,使用redis
        securityManager.setCacheManager(redisCacheManager());
        return securityManager;
    }

    //开启对shiro注解的支持
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(@Qualifier("securityManager") DefaultWebSecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }

    //开启aop注解支持
    @Bean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator defaultAAP = new DefaultAdvisorAutoProxyCreator();
        defaultAAP.setProxyTargetClass(true);
        return defaultAAP;
    }

    /**
     * cacheManager 缓存 redis实现
     * 使用的是shiro-redis开源插件
     *
     * @return
     */
    public RedisCacheManager redisCacheManager() {
        log.info("===============(1)创建缓存管理器RedisCacheManager");
        RedisCacheManager redisCacheManager = new RedisCacheManager();
        redisCacheManager.setRedisManager(redisManager());
        //redis中针对不同用户缓存(此处的id需要对应user实体中的id字段,用于唯一标识)
        redisCacheManager.setPrincipalIdFieldName("id");
        //用户权限信息缓存时间(单位：秒)
        redisCacheManager.setExpire(1800);
        return redisCacheManager;
    }

    /**
     * 配置shiro redisManager
     * 使用的是shiro-redis开源插件
     *
     * @return
     */
    @Bean
    public IRedisManager redisManager() {
        log.info("===============(2)创建RedisManager,连接Redis..");
        IRedisManager manager;
        // redis 单机支持，在集群为空，或者集群无机器时候使用
        if (lettuceConnectionFactory.getClusterConfiguration() == null || lettuceConnectionFactory.getClusterConfiguration().getClusterNodes().isEmpty()) {
            RedisManager redisManager = new RedisManager();
            redisManager.setHost(lettuceConnectionFactory.getHostName());
            redisManager.setPort(lettuceConnectionFactory.getPort());
            redisManager.setDatabase(lettuceConnectionFactory.getDatabase());
            redisManager.setTimeout(0);
            if (!StringUtils.isEmpty(lettuceConnectionFactory.getPassword())) {
                redisManager.setPassword(lettuceConnectionFactory.getPassword());
            }
            manager = redisManager;
        }else{
            // redis集群支持，优先使用集群配置
            RedisClusterManager redisManager = new RedisClusterManager();
            Set<HostAndPort> portSet = new HashSet<>();
            lettuceConnectionFactory.getClusterConfiguration().getClusterNodes().forEach(node -> portSet.add(new redis.clients.jedis.HostAndPort(node.getHost() , node.getPort())));
            //修改集群模式下未设置redis密码的bug issues/I3QNIC
            if (StringUtils.isNotEmpty(lettuceConnectionFactory.getPassword())) {
                JedisCluster jedisCluster = new JedisCluster(portSet, 2000, 2000, 5, lettuceConnectionFactory.getPassword(), new GenericObjectPoolConfig());
                redisManager.setPassword(lettuceConnectionFactory.getPassword());
                redisManager.setJedisCluster(jedisCluster);
            } else {
                JedisCluster jedisCluster = new JedisCluster(portSet);
                redisManager.setJedisCluster(jedisCluster);
            }
            //修改集群模式下未设置redis密码的bug issues/I3QNIC
            manager = redisManager;
        }
        return manager;
    }

}
```

### 自定义realm

```java
package com.zzp.seckilldemo.config.shiro;

import com.zzp.seckilldemo.common.utils.JwtUtil;
import com.zzp.seckilldemo.entity.User;
import com.zzp.seckilldemo.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;


/**
 * @Author zzp
 * @Date 2023/3/27 19:52
 * @Description: 自定义realm
 * @Version 1.0
 */
@Component
@Slf4j
public class ShiroRealm extends AuthorizingRealm {

    @Autowired
    private UserService userService;

    /**
     * 必须重写此方法，不然Shiro会报错
     * 限定这个realm只能处理JwtToken
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof JwtToken;
    }

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        log.info("===============Shiro权限认证开始============ [ roles、permissions]==========");
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        if (principals != null){
            // 获取认证方法中查到的当前登录用户信息 : User 对象
            User currentUser = (User) principals.getPrimaryPrincipal();
            // 获取当前用户在数据库中查询到的拥有的权限, 并为当前用户设置该权限
            info.addStringPermissions(userService.getPerms(currentUser));
        }
        return info;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken auth) throws AuthenticationException {
        log.info("===============Shiro身份认证开始============doGetAuthenticationInfo==========");

        //获取token信息
        String token = (String) auth.getCredentials();
        // 校验token：未校验通过或者已过期
        if (!JwtUtil.verifyToken(token)) {
            throw new AuthenticationException("请先登录");
        }
        Long userId = JwtUtil.getUserIdByJwtToken(token);
        User user = userService.getById(userId);
        if (user == null) {
            throw new AuthenticationException("用户不存在!");
        }
        return new SimpleAuthenticationInfo(user, token, getName());
    }

    /**
     * 清除当前用户的权限认证缓存
     *
     * @param principals 权限信息
     */
    @Override
    public void clearCache(PrincipalCollection principals) {
        super.clearCache(principals);
    }

}
```

### JwtToken

shiro 在没有和 jwt 整合之前，用户的账号密码被封装成了 UsernamePasswordToken 对象，UsernamePasswordToken 其实是 AuthenticationToken 的实现类。

既然要和 jwt 整合，Jw'tFilter 传递给 Realm 的 token 必须是 AuthenticationToken 的实现类。

```java
package com.zzp.seckilldemo.config.shiro;

import org.apache.shiro.authc.AuthenticationToken;

/**
 * @Author zzp
 * @Date 2023/3/27 22:05
 * @Description: TODO
 * @Version 1.0
 */
public class JwtToken implements AuthenticationToken {

    private static final long serialVersionUID = 1L;
    private String token;

    public JwtToken(String token) {
        this.token = token;
    }

    @Override
    public Object getPrincipal() {
        return token;
    }

    @Override
    public Object getCredentials() {
        return token;
    }
}
```

以注解的形式开启权限限制，realm中的doGetAuthorizationInfo()权限认证方法，只有在发生权限认证时才会触发。

需要在ShiroConfig中配置开启注解的代码。

![6300902d3ca3ae33f47670dec9a76e8](.\imgs\6300902d3ca3ae33f47670dec9a76e8.png)

配置全局异常处理

```java
@ExceptionHandler(value = ShiroException.class)
public Result<?> handleShiroException(ShiroException e) {
    return Result.error(CommonConstant.SC_NO_AUTHZ, "访问权限认证未通过");
}
```

### Shiro+Redis缓存权限

应用场景：Shiro为每个用户的角色和权限信息提供缓存支持，通过Shiro自己定义的CacheManager实现，默认实现有Ehcache和内存（就是一个Map结构），在应用中通常使用redis作为缓存服务器，因此使用redis来作为shiro的缓存。
优缺点：一般来说缓存放在本地，通过本地内存进行缓存速度更快，但是在分布式环境下，修改了用户权限需要进行同步。将缓存和Session放在统一的地方进行管理可以解决，但是网络请求延迟较高，且容易造成瞬间高并发。

```xml
<!-- redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
<!--shiro+Redis-->
<dependency>
    <groupId>org.crazycake</groupId>
    <artifactId>shiro-redis</artifactId>
    <version>3.1.0</version>
</dependency>
```

在ShiroConfig中添加

```java
/**
     * cacheManager 缓存 redis实现
     * 使用的是shiro-redis开源插件
     *
     * @return
     */
public RedisCacheManager redisCacheManager() {
    log.info("===============(1)创建缓存管理器RedisCacheManager");
    RedisCacheManager redisCacheManager = new RedisCacheManager();
    redisCacheManager.setRedisManager(redisManager());
    //redis中针对不同用户缓存(此处的id需要对应user实体中的id字段,用于唯一标识)
    redisCacheManager.setPrincipalIdFieldName("id");
    //用户权限信息缓存时间(单位：秒)
    redisCacheManager.setExpire(20);
    return redisCacheManager;
}

/**
     * 配置shiro redisManager
     * 使用的是shiro-redis开源插件
     *
     * @return
     */
@Bean
public IRedisManager redisManager() {
    log.info("===============(2)创建RedisManager,连接Redis..");
    IRedisManager manager;
    // redis 单机支持，在集群为空，或者集群无机器时候使用
    if (lettuceConnectionFactory.getClusterConfiguration() == null || lettuceConnectionFactory.getClusterConfiguration().getClusterNodes().isEmpty()) {
        RedisManager redisManager = new RedisManager();
        redisManager.setHost(lettuceConnectionFactory.getHostName());
        redisManager.setPort(lettuceConnectionFactory.getPort());
        redisManager.setDatabase(lettuceConnectionFactory.getDatabase());
        redisManager.setTimeout(0);
        if (!StringUtils.isEmpty(lettuceConnectionFactory.getPassword())) {
            redisManager.setPassword(lettuceConnectionFactory.getPassword());
        }
        manager = redisManager;
    }else{
        // redis集群支持，优先使用集群配置
        RedisClusterManager redisManager = new RedisClusterManager();
        Set<HostAndPort> portSet = new HashSet<>();
        lettuceConnectionFactory.getClusterConfiguration().getClusterNodes().forEach(node -> portSet.add(new redis.clients.jedis.HostAndPort(node.getHost() , node.getPort())));
        //修改集群模式下未设置redis密码的bug issues/I3QNIC
        if (StringUtils.isNotEmpty(lettuceConnectionFactory.getPassword())) {
            JedisCluster jedisCluster = new JedisCluster(portSet, 2000, 2000, 5, lettuceConnectionFactory.getPassword(), new GenericObjectPoolConfig());
            redisManager.setPassword(lettuceConnectionFactory.getPassword());
            redisManager.setJedisCluster(jedisCluster);
        } else {
            JedisCluster jedisCluster = new JedisCluster(portSet);
            redisManager.setJedisCluster(jedisCluster);
        }
        //修改集群模式下未设置redis密码的bug issues/I3QNIC
        manager = redisManager;
    }
    return manager;
}
```

![1a132b066a3d2658b08fa6220c7a618](.\imgs\1a132b066a3d2658b08fa6220c7a618.png)

## JMeter压力测试

下载地址：https://jmeter.apache.org/download_jmeter.cgi

### Windows启动JMeter

![b667e28d8b04465a187a66a34f03cac](.\imgs\b667e28d8b04465a187a66a34f03cac.png)

### CentOS 7安装JMeter

![225941de517673b550c158e95fb33e6](.\imgs\225941de517673b550c158e95fb33e6.png)

进入bin文件夹中，vim jmeter.properties 修改配置

![12b830217468378333f1823944768ec](.\imgs\12b830217468378333f1823944768ec.png)

设置编码格式 sampleresult.default.encoding=UTF-8

![e78640dd166fb09f2a56f555840570a](.\imgs\e78640dd166fb09f2a56f555840570a.png)

CentOS中没有图形化界面，使用较为麻烦，可以在windows中使用JMeter配置好测试内容，保存xxx.jmx文件，并将该文件复制到 JMeter 的 bin 目录中

![bfb2266cb4ffd7134ffb5f662a66634](.\imgs\bfb2266cb4ffd7134ffb5f662a66634.png)

执行JMeter, -n 表示非图形化执行 ， -t 表示要执行的测试文件 ， -l 表示保存测试结果的文件

```shell
./jmeter.sh -n -t seckill.jmx -l result.jtl
```

将生成 result.jtl 拷贝到 windows中

![ea1d23907f34da7ac718c1dee64cf3c](.\imgs\ea1d23907f34da7ac718c1dee64cf3c.png)

在聚合报告中，点击浏览，选中  result.jtl 查看结果

![6ba80cb55601c9550468cc899be301c](.\imgs\6ba80cb55601c9550468cc899be301c.png)

### 秒杀接口压测

1. 使用Navicat生成用户数据（模拟多用户秒杀）
2. 因请求秒杀接口需要token，而token需要登录成功后，才会生成，在测试类中生成用于测试的token
3. 将生成的token，保存在tokens.csv文件中

```java
/**
     * 生成用户token 用于JMeter测试
     */
@Test
public void generateToken() {
    List<User> userList = userService.list();

    try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("C:\\Users\\Goku\\Desktop\\tokens.csv"));) {
        for (User user : userList) {
            String token = JwtUtil.creatToken(user.getId(), user.getNickname()) + ",";
            bos.write(token.getBytes(StandardCharsets.UTF_8));
            bos.write("\r\n".getBytes()); //换行
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

- 在JMeter中导入tokens.csv文件，通过${变量名}的方式，读取csv中的值（会自动读取csv中每一行的值）
- 当一行有多个参数时，设置多个变量名，并设置分隔符

![fd59d0fae5c7608e07a211f269fb7f7](.\imgs\fd59d0fae5c7608e07a211f269fb7f7.png)

![a50a88d47d1071c0ac2a5d4651411d3](.\imgs\a50a88d47d1071c0ac2a5d4651411d3.png)

## Redis缓存数据对象

对商品列表接口返回数据缓存至redis中

```markdown
* 常用的SpringBoot缓存注解有@Cacheable、@CacheEvit、@CachePut，含义分别为：
*
* 1、@Cacheable：修饰方法或类，当我们访问它修饰的方法时，优先从缓存中获取，若缓存中存在，则直接获取缓存的值；缓存不存在时，执行方法，并将结果写入缓存，value表示缓存名，key表示自定义缓存key
*
* 2、@CacheEvit：删除缓存，一般用在更新或者删除方法上，value表示缓存名，allEntries表示是否清空所有缓存
*
* 3、@CachePut：不管缓存有没有，都将方法的返回结果写入缓存；适用于缓存更新
```

![ec6c294908014a108f3270f20f01728](.\imgs\ec6c294908014a108f3270f20f01728.png)

在RedisConfig中配置缓存过期时间

![b59dac6843e704e20c94e2f3124ac79](.\imgs\b59dac6843e704e20c94e2f3124ac79.png)

## 秒杀问题

黑马Redis教程：p48-p77

https://www.bilibili.com/video/BV1cr4y1671t?p=48&vd_source=a30b314e5518529404e5cbd4ba5dbcd5

资料：[E:\Documents\后端学习资料\Redis\02-实战篇\讲义\Redis实战篇.md]()

### 秒杀超卖问题（单机）

基于乐观锁（CAS方式）实现

```java
/**
     * 
     * @param request 获取token
     * @param goodsId 商品id
     * @param purchaseCount 购买数量
     */
@PostMapping("/doSecKill/{goodsId}/{purchaseCount}")
public Result doSecKill(HttpServletRequest request, @PathVariable("goodsId") Long goodsId, @PathVariable("purchaseCount") Integer purchaseCount) {
    //从token中获取userId
    Long userId = JwtUtil.getUserIdByJwtToken(request.getHeader(CommonConstant.X_ACCESS_TOKEN));
    Goods goods;
    if (redisTemplate.opsForValue().get("goods:" + goodsId) != null) {
        goods = (Goods) redisTemplate.opsForValue().get("goods:" + goodsId);
    } else {
        goods = goodsService.getById(goodsId);
        //缓存商品信息
        redisTemplate.opsForValue().set("goods:" + goodsId, goods, 300, TimeUnit.SECONDS);
    }

    SeckillGoods seckillGoods = seckillGoodsService.getOne(new QueryWrapper<SeckillGoods>().eq("goods_id", goodsId));

    if (seckillGoods.getStockCount() < purchaseCount || seckillGoods.getStockCount() < 1) {
        return Result.error(CommonConstant.SEC_KILL_601, "库存不足");
    }
    //判断用户是否重复抢购
    QueryWrapper<SeckillOrder> wrapper = new QueryWrapper<>();
    wrapper.eq("user_id", userId).eq("goods_id", goodsId);
    long count = seckillOrderService.count(wrapper);
    if (count != 0) {
        return Result.error(CommonConstant.SEC_KILL_601, "不能重复抢购");
    }
    //扣减库存
    //乐观锁（CAS方式）
    boolean create = seckillGoodsService.update()
        .setSql("stock_count = stock_count - " + purchaseCount)
        .eq("goods_id", goodsId)
      //.eq("stock_count", seckillGoods.getStockCount()) //并发抢购失败率高，库存仍有余量
        .gt("stock_count",0) //改进方案，库存大于0，即可扣减库存
        .update();
    if (create) {
        //创建订单
        orderService.creatOrder(userId, goods, seckillGoods, purchaseCount);
    }
    return Result.ok("抢购成功");
}
```

### 秒杀一人一单问题(单机)

方式一：添加 user_id 与 goods_id 的唯一索引，插入数据时，数据库自动检查

![771ec93ed8e327be1c53a6d2e3735bd](E:\Documents\后端学习资料\学习项目\imgs\771ec93ed8e327be1c53a6d2e3735bd.png)

方式二：悲观锁，锁住同一用户id

https://blog.csdn.net/qq_33753147/article/details/126414735

```JAVA
/**
     * @param request       获取token
     * @param goodsId       商品id
     * @param purchaseCount 购买数量
     */
@PostMapping("/doSecKill/{goodsId}/{purchaseCount}")
public Result doSecKill(HttpServletRequest request, @PathVariable("goodsId") Long goodsId, @PathVariable("purchaseCount") Integer purchaseCount) {
    //从token中获取userId
    Long userId = JwtUtil.getUserIdByJwtToken(request.getHeader(CommonConstant.X_ACCESS_TOKEN));
    Goods goods;
    if (redisTemplate.opsForValue().get("goods:" + goodsId) != null) {
        goods = (Goods) redisTemplate.opsForValue().get("goods:" + goodsId);
    } else {
        goods = goodsService.getById(goodsId);
        //缓存商品信息
        redisTemplate.opsForValue().set("goods:" + goodsId, goods, 300, TimeUnit.SECONDS);
    }

    /**
         *   Long是一个对象,但相同值的Long每一次对象都是不同的，
         *   所以要对值加锁,但是toString的底层是new String所以还是对象加锁
         *   所以要调用String的intern方法，在常量池中找值相同的引用,则所有都一样
         *   synchronized放在事务中（@Transactional）存在问题, Transaction的事务是在方法结束时才会提交,
         *   在并发的情况下也会存在事务还没提交,锁已经释放,存在可能同一个ID进入同步块的情况，所以要放在@Transactional的外面
         *    保证事务提交后，才能再次进入此方法
         */
    synchronized (userId.toString().intern()) {
        SeckillGoods seckillGoods = seckillGoodsService.getOne(new QueryWrapper<SeckillGoods>().eq("goods_id", goodsId));

        //判断库存
        if (seckillGoods.getStockCount() < purchaseCount || seckillGoods.getStockCount() < 1) {
            return Result.error(CommonConstant.SEC_KILL_601, "库存不足");
        }
        //判断用户是否重复抢购
        long count = seckillOrderService.count(new QueryWrapper<SeckillOrder>()
                                               .eq("user_id", userId)
                                               .eq("goods_id", goodsId));
        if (count != 0) {
            return Result.error(CommonConstant.SEC_KILL_601, "不能重复抢购");
        }
        //扣减库存
        //乐观锁（CAS方式）
        boolean create = seckillGoodsService.update()
            .setSql("stock_count = stock_count - " + purchaseCount)
            .eq("goods_id", goodsId)
            //                .eq("stock_count", seckillGoods.getStockCount()) //并发抢购失败率高，库存仍有余量
            .gt("stock_count", 0) //改进方案，库存大于0，即可扣减库存
            .update();
        if (create) {
            //创建订单 事务方法creatOrder
            orderService.creatOrder(userId, goods, seckillGoods, purchaseCount);
        }
    }
    return Result.ok("抢购成功");
}
```

### 集群问题

- 开启2台服务器时，每台服务器只能锁住自身服务范围内的userId，保证在自身服务器内，不会出现重复下单情况
- 因此在开启多台服务器时会出现重复下单现象

![76d1fedcdedf5950980d45f711f51f9](.\imgs\76d1fedcdedf5950980d45f711f51f9.png)

### 分布式锁

- 满足分布式系统或集群模式下多进程可见并且互斥的锁
- 使用分布式锁解决重复下单现象

![1653382219377](.\imgs\1653382219377.png)

#### 基于Redis的分布式锁

```java
public interface Lock {

    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有时间，过期后自动释放
     * @return true：获取成功 false：获取失败
     */
    boolean tryLock(long timeoutSec);

    //释放锁
    void unlock();
}
```

释放分布式锁之前，要判断是否为当前线程的锁，若是则释放

```java
package com.zzp.seckilldemo.common.utils.distributedLock;

import cn.hutool.core.lang.UUID;
import org.springframework.data.redis.core.RedisTemplate;

import java.util.concurrent.TimeUnit;

/**
 * @Author zzp
 * @Date 2023/4/5 16:47
 * @Description: TODO
 * @Version 1.0
 */
public class SimpleRedisLock implements Lock {

    //锁名称前缀
    private static final String KEY_LOCK_PREFIX = "lock:";
    //value前缀 toString(true)去掉 uuid中的-
    private static final String VALUE_ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    //锁名称
    private String lockName;

    private RedisTemplate redisTemplate;

    public SimpleRedisLock(RedisTemplate redisTemplate, String lockName) {
        this.lockName = lockName;
        this.redisTemplate = redisTemplate;
    }

    @Override
    public boolean tryLock(long timeoutSec) {
        //获取线程标识
        String threadId = VALUE_ID_PREFIX + Thread.currentThread().getId();

        //获取锁 setnx
        Boolean success = redisTemplate.opsForValue().setIfAbsent(KEY_LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    @Override
    public void unlock() {
        //获取线程标识
        String threadId = VALUE_ID_PREFIX + Thread.currentThread().getId();
        String id = (String) redisTemplate.opsForValue().get(KEY_LOCK_PREFIX + lockName);

        if (threadId.equals(id)) {
            //释放锁
            redisTemplate.delete(KEY_LOCK_PREFIX + lockName);
        }

    }
}
```

```java
    /**
     * 分布式/集群模式
     *
     * @param request       获取token
     * @param goodsId       商品id
     * @param purchaseCount 购买数量
     */
    @PostMapping("/doSecKill/{goodsId}/{purchaseCount}")
    public Result doSecKill(HttpServletRequest request, @PathVariable("goodsId") Long goodsId, @PathVariable("purchaseCount") Integer purchaseCount) {

        //从token中获取userId
        Long userId = JwtUtil.getUserIdByJwtToken(request.getHeader(CommonConstant.X_ACCESS_TOKEN));

        //创建锁对象,锁住同一userId
        SimpleRedisLock redisLock = new SimpleRedisLock(redisTemplate, "order:" + userId);
        //获取锁
        boolean isLock = redisLock.tryLock(600);
        //判断是否获取锁成功
        if (!isLock) {
            return Result.error(CommonConstant.SEC_KILL_601, "请勿重复抢购");
        }

        try {
            SeckillGoods seckillGoods = seckillGoodsService.getOne(new QueryWrapper<SeckillGoods>().eq("goods_id", goodsId));
            //判断库存
            if (seckillGoods.getStockCount() < purchaseCount || seckillGoods.getStockCount() < 1) {
                return Result.error(CommonConstant.SEC_KILL_601, "库存不足");
            }

            //判断用户是否重复抢购
            long count = seckillOrderService.count(new QueryWrapper<SeckillOrder>()
                    .eq("user_id", userId)
                    .eq("goods_id", goodsId));
            if (count != 0) {
                return Result.error(CommonConstant.SEC_KILL_601, "不能重复抢购");
            }
            //扣减库存
            //乐观锁（CAS方式）
            boolean create = seckillGoodsService.update()
                    .setSql("stock_count = stock_count - " + purchaseCount)
                    .eq("goods_id", goodsId)
//                .eq("stock_count", seckillGoods.getStockCount()) //并发抢购失败率高，库存仍有余量
                    .gt("stock_count", 0) //改进方案，库存大于0，即可扣减库存
                    .update();
            if (create) {
                //创建订单 事务方法creatOrder
                orderService.creatOrder(userId, goodsId, seckillGoods, purchaseCount);
            }

        } finally {
            redisLock.unlock();
        }

        return Result.ok("抢购成功");
    }
```

注：配置nginx负载均衡时，当一次请求量过大时，会出现有的请求无法正确发送，导致请求失败

使用JMeter测试时，要合理设置单次请求的线程数

![5b53fb00ce3468a688238670295308f](.\imgs\5b53fb00ce3468a688238670295308f.png)

#### Lua脚本优化释放锁过程

在idea中安装 EmmyLua 插件

```lua
-- 锁的key
-- local key = KEYS[1]
-- 当前线程标识
-- local threadId = ARGV[1]

-- 获取锁中的线程标识
-- local id = redis.call('get', KEYS[1])

-- 比较线程标识与锁中的标识是否一致
if (redis.call('get', KEYS[1]) == ARGV[1]) then
    -- 释放锁
    return redis.call('del', KEYS[1])
end
return 0
```

```java
package com.zzp.seckilldemo.common.utils.distributedLock;

import cn.hutool.core.lang.UUID;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;

import java.util.Collections;
import java.util.concurrent.TimeUnit;

/**
 * @Author zzp
 * @Date 2023/4/5 16:47
 * @Description: TODO
 * @Version 1.0
 */
public class SimpleRedisLock implements Lock {

    //读取lua脚本文件,初始化
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

    //锁名称前缀
    private static final String KEY_LOCK_PREFIX = "lock:";
    //value前缀 toString(true)去掉 uuid中的-
    private static final String VALUE_ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    //锁名称
    private String lockName;

    private RedisTemplate redisTemplate;

    public SimpleRedisLock(RedisTemplate redisTemplate, String lockName) {
        this.lockName = lockName;
        this.redisTemplate = redisTemplate;
    }

    @Override
    public boolean tryLock(long timeoutSec) {
        //获取线程标识
        String threadId = VALUE_ID_PREFIX + Thread.currentThread().getId();

        //获取锁 setnx
        Boolean success = redisTemplate.opsForValue().setIfAbsent(KEY_LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    @Override
    public void unlock() {
        //调用Lua脚本
        redisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_LOCK_PREFIX + lockName),
                VALUE_ID_PREFIX + Thread.currentThread().getId());
    }
}
```

## 前后端分离打包部署Linux

### 方式一：将vue项目打包，添加到SpringBoot项目中

1.修改BASE_API

![5fcbdaeada72980fb8f09dda0e3be95](.\imgs\5fcbdaeada72980fb8f09dda0e3be95.png)

2.修改package.json中添加build模式

![e41ab5bcf5d75bf41ce9b1a59968f35](.\imgs\e41ab5bcf5d75bf41ce9b1a59968f35.png)

3. 在控制台输入

   ```shell
   npm run build:dev  或  npm run build:prod
   ```

    打包对应环境，会生成dist文件夹

![1c9263e986c28bbc7689a7bae15eece](.\imgs\1c9263e986c28bbc7689a7bae15eece.png)

4.将dist文件夹中的文件拷贝到resource/static中，并修改SpringBoot的配置信息

![45dcd8927a109f8f078732124e20dc1](.\imgs\45dcd8927a109f8f078732124e20dc1.png)

5.点击跳过打包测试，先执行clean，再执行package，会生成target文件夹，将文件夹中的 xxxx.jar 文件拷贝到Linxu中执行即可

![f5781f4fa32f2d0f9b20d5ee69ef16a](.\imgs\f5781f4fa32f2d0f9b20d5ee69ef16a.png)